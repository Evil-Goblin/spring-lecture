## 준영속 엔티티
- detach 이외에도 식별자(id)를 가지고 있지만 영속성 컨텍스트에 포함되지 않은 엔티티이다.
- update등과 같이 이미 db에 정보가 있는 데이터가 그것이다.

## 준영속 엔티티의 변경
- 변경감지
  - id를 통해 다시 find하여 영속성 컨텍스트에 포함시킨 후 값을 변경하여 더티체킹을 이용한다.
- 병합
  - 준영속 상태의 엔티티를 영속성컨텍스트에 포함시켜주는 역할을 한다.
  - 결국 자동으로 변경감지를 위한 find, set등을 진행해준다. (수동으로 변경감지를 이용하려던 것을 자동으로 해준다.)
    - 모든 속성이 변경된다.(주의!!!)
    - 만약 값이 없는 칼럼에 대해서 null로 세팅될 가능성이 있다.(주의!!!)
  - merge의 파라미터로 넘기는 값은 영속성 컨텍스트에 관리되지 않는다.
  - merge의 리턴값이 영속성 컨텍스트에 관리된다.
  - 왠만하면 변경감지를 이용하는 방식으로(수동) 사용하는것이 좋다.(merge 를 쓰지 않는 방향으로)

## select 팁
- ToOne 관계는 무조건 fetch join 을 사용하라
- 컬렉션은 지연로딩으로 조회하라
- 지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size, @BatchSize 를 적용하라
  - 이 옵션을 적용하면 N+1 문제가 발생하는 쿼리를 한방에 가져오도록 변경된다.(N+1 을 1+1 쿼리로, N+M+1 쿼리를 1+1+1쿼리로)

## 순서
- 엔티티 조회 방식으로 우선 접근
  - fetch join 으로 쿼리 수 최적화
  - 컬렉션 최적화
    - 페이징 필요시 BatchSize 옵션을 통해 최적화
    - 페이징 불필요시 fetch join 사용
- 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
  - DTO 로 조회하게 되면 사실상 SQL을 직접 다루는거와 진배없다...
- DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate 으로 최적화한다.

## Open Session In View
- Default 값은 true 이다.
- 세션의 유지를 응답이 나갈때 까지 유지해준다.
- 영속성 컨텍스트는 세션을 기반으로 하기 때문에 응답까지 세션을 유지해주면 Transaction 어노테이션이 걸려있는 범위 밖에서도 유지가 된다.
  - 일반적으로 service에 트랜잭션을 적용하지만 service에서 리턴되어 나온 controller에서도 영속성 컨텍스트가 유지되어 지연로딩 등을 사용할 수 있다.
  - 어디에서나 지연로딩등을 사용할 수 있다는 장점이 있다.
  - 하지만 세션을 오래 유지하기 때문에 성능상 아쉽다.
- 
