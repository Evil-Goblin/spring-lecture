## jpa 서브쿼리의 한계
- JPA 는 where, having 절에서만 서브쿼리 가능
- 하이버네이트에서는 select 절에서 가능하다.
- from 절의 서브쿼리는 현재 jpql에서 불가능하다.
  - join 으로 풀 수 있으면 풀어서 해결...

## fetch join 특징과 한계
- fetch join 대상에는 별칭을 줄 수 없다.
  - 하이버네이트는 가능하지만 가급적 사용하지 않는 것이 권장된다.
- 둘 이상의 컬렉션은 fetch join 할 수 없다.
- 컬렉션을 fetch join 하면 페이징 api (setFirstResult, setMaxResults)를 사용할 수 없다.
  - 일대일, 다대일 같은 단일 값 연관 필드들은 fetch join 해도 페이징 가능
  - 일대다의 경우 fetch시 조회결과가 뻥튀기된다. (일에 해당하는 다가 전부 조회되기 때문)
  - 이에 일대다는 페이징에 문제가 생긴다.
- 연관된 엔티티들을 sql 한 번으로 조회 - 성능 최적화
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선순위가 높다.
  - FetchType.LAZY 로 설정되어있어도 fetch join 을 통해 한번에 가져올 수 있다.
- 글로벌 로딩 전략은 모두 지연 로딩으로 사용해야한다.
- 최적화가 필요한 곳에서 fetch join 사용하도록 한다.

## 엔티티 직접 사용
- JPQL에서 엔티티를 직접 사용하면 sql에서 해당 엔티티의 기본 키 값을 사용
  - `select count(m) from Member m` -> `select count(m.id) as cnt from Member m`

## Named 쿼리
- XML 이 항상 우선권을 가진다.

## bulk 연산
- 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다.
  - 벌크 연산을 먼저 실행 (영속성 컨텍스트가 비워져있는 채로 먼저 실행하면 영속성 컨텍스트에 영향이 없다.)
  - 벌크 연산 수행 후 영속성 컨텍스트 초기화 (벌크 연산이후 데이터베이스와 영속성 컨텍스트의 값이 다를 수 있기 때문에 영속성 컨텍스트를 초기화 해야한다.)
